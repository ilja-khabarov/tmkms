/// JSON-RPC interface for transaction signing

use jsonrpc_ws_server::*;
use jsonrpc_ws_server::jsonrpc_core::*;
use jsonrpc_core::{
    futures::{self, FutureExt},
    BoxFuture, IoHandler, Result,
};
use jsonrpc_core_client::transports::local;
use jsonrpc_derive::rpc;
use ethereum_tx_sign::RawTransaction;
use ethereum_types::H256;
use crate::other_signers::eth_signer::EthTxSigner;
use std::path::Path;

#[rpc]
pub trait SignEthereumRpc {
    #[rpc(name = "sign_eth_tx")]
    fn sign_eth_tx(&self, tx: RawTransaction) -> BoxFuture<Result<Vec<u8>>>;
}

const ETH_MAIN_NET_ID: u32 = 1;
const ETH_ROPSTEIN_NET_ID: u32 = 3;

#[derive(Clone)]
pub struct SignEthereumImpl{
    signer: Pin<Box<EthTxSigner>>,
}

impl SignEthereumImpl {
    pub fn from_key(raw_key: &[u8]) -> Result<Self> {
        EthTxSigner::new(raw_key)
            .map(|s| Self{signer:s.boxed()})
            .map_err(|e| {
                let message = format!("{}", e);
                jsonrpc_core::Error::invalid_params(message)
            })
    }

    pub fn from_json_file<P: AsRef<Path>>(path: &P) -> Result<Self>
    {
        EthTxSigner::load_json_file(path)
            .map(|s| Self{signer:s.boxed()})
            .map_err(|e| {
                let message = format!("{}", e);
                jsonrpc_core::Error::invalid_params(message)
            })
    }
}

use std::future::Future;
use futures_util::TryFutureExt;
use std::pin::Pin;

impl SignEthereumRpc for SignEthereumImpl {
    // todo: stubbed
    fn sign_eth_tx(&self, tx: RawTransaction) -> BoxFuture<Result<Vec<u8>>> {
        //let signature = self.signer.sign_eth_transaction(tx);
        //let result = futures_executor::block_on(self.signer.sign_eth_transaction(tx));
        //let s = tokio::spawn(self.signer.sign_eth_transaction(tx));
        //Box::pin(jsonrpc_core::futures::future::ready(Ok(result)))
        //let foo = self.signer.sign_eth_transaction(tx);
        let clone = self.clone();
        let a = async {
            let clone = clone;
            Ok(clone.signer.sign_eth_transaction(tx))
        }.boxed();
        a
    }
}

pub fn start_server(signer: EthTxSigner) {
    let mut io = IoHandler::default();
    let pinned = Box::pin(signer);
    let signer = SignEthereumImpl{ signer: pinned };
    io.extend_with(signer.to_delegate());

    let server = ServerBuilder::new(io)
        .start(&"0.0.0.0:3030".parse().unwrap())
        .expect("Server must start with no issues");

    server.wait().unwrap()
}

#[test]
fn test_signing() {
    futures::executor::block_on(async {
        let mut io = IoHandler::new();
        let signer = SignEthereumImpl::default();
        io.extend_with(signer.to_delegate());
        println!("Starting local server");
        let (client, server) = local::connect(io);
        let client = use_client(client).fuse();
        let server = server.fuse();

        futures::pin_mut!(client);
        futures::pin_mut!(server);

        futures::select! {
			_server = server => {},
			_client = client => {},
		}
    });
    start_server()
}

/// Hint: SignEthereumRpcClient is generated by [#rpc] macro.
async fn use_client(client: SignEthereumRpcClient) {
    let msg = ethereum_tx_sign::RawTransaction {
        nonce: ethereum_types::U256::from(0),
        to: Some(ethereum_types::H160::zero()),
        value: Default::default(),
        gas_price: ethereum_types::U256::from(10000),
        gas: ethereum_types::U256::from(21240),
        data: hex::decode(
            "7f7465737432000000000000000000000000000000000000000000000000000000600057"
        ).unwrap()
    };

    println!("{}", serde_json::to_string_pretty(&msg).unwrap());

    let mut data: [u8; 32] = Default::default();
    data.copy_from_slice(&hex::decode(
        "2a3526dd05ad2ebba87673f711ef8c336115254ef8fcd38c4d8166db9a8120e4"
    ).unwrap());
    let private_key = ethereum_types::H256(data);
    let raw_rlp_bytes = client.sign_eth_tx(msg).await.unwrap();
    let result = "f885808227108252f894000000000000000000000000000000000000000080a\
        47f746573743200000000000000000000000000000000000000000000000000\
        00006000572aa0b4e0309bc4953b1ca0c7eb7c0d15cc812eb4417cbd759aa09\
        3d38cb72851a14ca036e4ee3f3dbb25d6f7b8bd4dac0b4b5c717708d20ae6ff\
        08b6f71cbf0b9ad2f4";

    assert_eq!(result, hex::encode(raw_rlp_bytes));
}
